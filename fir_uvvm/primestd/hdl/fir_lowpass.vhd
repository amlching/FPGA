--------------------------------------------------------------------------------
--! @file            fir_lowpass.vhd
--! @brief           This unit infers fir filter, 21 taps, 1 or 2 decimation, 
--!					 sampling frequency 2khz, passes 0 to 400Hz, filters out 500hz to 1000Hz (nyquist).
--!					 Coefficients are generated by http://t-filter.engineerjs.com/, passed in as generic. 
--!					 It requires and expects reset at the beginning of every packet.
--! 				 Code inspired by https://surf-vhdl.com/how-to-implement-fir-filter-in-vhdl/
--!
--! @author          Alex Ching
--! @date            03-01-2025
--! @version
--! @verbatim Version  Change                                         Author  Date        \endverbatim
--! @verbatim  1       initial release                                AC     31-01-2025  \endverbatim
-----------------------------------------------------------------------------

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

entity fir_lowpass is
  	generic ( -- default generic to fir																								   .
-- 21 coefs....	  
		COEFF_0 		: integer := -659;
		COEFF_1 		: integer := -1915;
		COEFF_2 		: integer := -2005;
		COEFF_3 		: integer := -358;
		COEFF_4 		: integer := 1679;
		COEFF_5 		: integer := 1089;
		COEFF_6 		: integer := -1853;
		COEFF_7 		: integer := -2807;
		COEFF_8 		: integer := 2077;
		COEFF_9 		: integer := 10186;
		COEFF_10 		: integer := 14235;
		COEFF_11 		: integer := 10186;
		COEFF_12 		: integer := 2077;
		COEFF_13 		: integer := -2807;
		COEFF_14 		: integer := -1853;
		COEFF_15 		: integer := 1089;
		COEFF_16 		: integer := 1679;
		COEFF_17 		: integer := -358;
		COEFF_18 		: integer := -2005;
		COEFF_19 		: integer := -1915;
		COEFF_20 		: integer := -659;
		NUM_TAPS		: natural := 21;
		DECIMATE_FACTOR	: natural := 2;	-- 1 for no decimation
        INPUT_WIDTH     : natural := 16;  
        OUTPUT_WIDTH    : natural := 33; -- COEF_WIDTH+INPUT_WIDTH+1 sign bit for all stage of additions  	  
        COEF_WIDTH      : natural := 16
  	);
    port (
	  clk              	: in  std_logic                     := 'X';             -- clk
	  reset_n          	: in  std_logic                     := 'X';             -- reset_n
	  sink_data    		: in  std_logic_vector(INPUT_WIDTH-1 downto 0) := (others => 'X'); -- data
	  sink_valid   		: in  std_logic                     := 'X';             -- valid
	  sink_error   		: in  std_logic_vector(1 downto 0)  := (others => 'X'); -- error
	  source_data  		: out std_logic_vector(OUTPUT_WIDTH-1 downto 0);                    -- data
	  source_valid 		: out std_logic;                                        -- valid
	  source_error 		: out std_logic_vector(1 downto 0)                      -- error
    );
end fir_lowpass;

--! @anchor filter-calculation
--! @brief fir filter, N taps with decimation factor 
--! @details FIR filter of order N, each value of the output sequence is a weighted sum 
--! of the most recent input values: y[n] = b0x[n]+b1x[n-1]+...bNx[n-N]
--! where x[n] is input, y[n] is output, N is filter order, bi is the coefficient, where 0<=i<=N.  
--! The FIR filter is implemented fully pipelined, there is a registration stage 
--! at the output of each multiplication or addition.  
--! Depending on the generic, the MSB of output is truncated to match the output data width.
--! NOTE: the internal variables are reset only with 'reset' input, so at the beginning of
--! each scan, the first values are clear with zeros.
--! This behaviour is the same as altera IP except this reset clears all value.
architecture rtl of fir_lowpass is

type t_data_pipe      is array (0 to NUM_TAPS-1) of signed(INPUT_WIDTH-1 downto 0);
type t_coeff          is array (0 to NUM_TAPS-1) of signed(COEF_WIDTH-1 downto 0);
-- When you multiply two numbers of N-bit and M-bit the output dynamic of the multiplication result is (N+M)-bits. 
type t_mult           is array (0 to NUM_TAPS-1) of signed(COEF_WIDTH+INPUT_WIDTH-1 downto 0); -- 16 bit coeff x 16 bit data = 32 bit length
-- When you perform addition, the number of bit of the result will be incremented by 1. 
type t_add_st1        is array (0 to 15) of signed(COEF_WIDTH+INPUT_WIDTH downto 0);
type t_add_st2        is array (0 to 7) of signed(COEF_WIDTH+INPUT_WIDTH+1 downto 0);
type t_add_st3        is array (0 to 3) of signed(COEF_WIDTH+INPUT_WIDTH+2 downto 0);
type t_add_st4        is array (0 to 1) of signed(COEF_WIDTH+INPUT_WIDTH+3 downto 0);
signal r_add_st1            : t_add_st1;
signal r_add_st2            : t_add_st2;
signal r_add_st3            : t_add_st3;
signal r_add_st4            : t_add_st4;
signal r_add_st5            : signed(COEF_WIDTH+INPUT_WIDTH+4 downto 0);

signal input_enable			: std_logic_vector(5 downto 0); 

signal r_coeff              : t_coeff ;
signal p_data               : t_data_pipe;
signal r_mult               : t_mult;

signal decimation_count 	: integer range 0 to DECIMATE_FACTOR;

signal source_valid_int : std_logic;

signal input_valid_count	: natural := 0;
signal output_valid_count	: natural := 0;

begin

-- concurrent assignment
r_coeff(0)  <= to_signed(COEFF_0, r_coeff(0)'length);
r_coeff(1)  <= to_signed(COEFF_1, r_coeff(1)'length);
r_coeff(2)  <= to_signed(COEFF_2, r_coeff(2)'length);
r_coeff(3)  <= to_signed(COEFF_3, r_coeff(3)'length);
r_coeff(4)  <= to_signed(COEFF_4, r_coeff(4)'length);
r_coeff(5)  <= to_signed(COEFF_5, r_coeff(5)'length);
r_coeff(6)  <= to_signed(COEFF_6, r_coeff(6)'length);
r_coeff(7)  <= to_signed(COEFF_7, r_coeff(7)'length);
r_coeff(8)  <= to_signed(COEFF_8, r_coeff(8)'length);
r_coeff(9)  <= to_signed(COEFF_9, r_coeff(9)'length);
r_coeff(10)  <= to_signed(COEFF_10, r_coeff(10)'length);
r_coeff(11)  <= to_signed(COEFF_11, r_coeff(11)'length);
r_coeff(12)  <= to_signed(COEFF_12, r_coeff(12)'length);		   
r_coeff(13)  <= to_signed(COEFF_13, r_coeff(13)'length);
r_coeff(14)  <= to_signed(COEFF_14, r_coeff(14)'length);
r_coeff(15)  <= to_signed(COEFF_15, r_coeff(15)'length);
r_coeff(16)  <= to_signed(COEFF_16, r_coeff(16)'length);
r_coeff(17)  <= to_signed(COEFF_17, r_coeff(17)'length);
r_coeff(18)  <= to_signed(COEFF_18, r_coeff(18)'length);
r_coeff(19)  <= to_signed(COEFF_19, r_coeff(19)'length);
r_coeff(20)  <= to_signed(COEFF_20, r_coeff(20)'length);

p_input : process (reset_n, clk)
begin
  if(reset_n='0') then
    p_data       <= (others=>(others=>'0'));
	input_valid_count <= 0;
  elsif(rising_edge(clk)) then
	if(sink_valid = '1') then
      p_data      <= signed(sink_data)&p_data(0 to p_data'length-2); 
	  input_valid_count <= input_valid_count + 1; 
    end if;
  end if;
end process p_input;

-- enable next stage addition only when new sample comes in
p_input_enable : process (reset_n, clk)
begin
  if(reset_n='0') then
    input_enable       <= (others => '0');
  elsif(rising_edge(clk)) then
      input_enable(0)     <= sink_valid; 
  	  input_enable(input_enable'left downto 1) <= input_enable(input_enable'left-1 downto 0);
  end if;
end process p_input_enable;

-- coefficient (tap) multiplier (convolution)
p_mult : process (reset_n, clk)
begin
  if(reset_n='0') then
    r_mult       <= (others=>(others=>'0'));
  elsif(rising_edge(clk)) then
	if(input_enable(0) = '1') then
    for k in 0 to NUM_TAPS-1 loop
      r_mult(k)       <= p_data(k) * r_coeff(k);
    end loop;
	end if;
  end if;
end process p_mult;

-- 21 tap multiplication output with addition convert to 5 stage addition, 
-- each addition stage increment bit count by 1

-- 21 to 16 stage 1 adder 
p_add_st1 : process (reset_n, clk)
begin
  if(reset_n='0') then
    r_add_st1     <= (others=>(others=>'0'));
  elsif(rising_edge(clk)) then
	if(input_enable(1) = '1') then
    for k in 0 to 9 loop -- 20 taps
      r_add_st1(k)     <= resize(r_mult(2*k),r_add_st1(k)'length) + resize(r_mult(2*k+1),r_add_st1(k)'length);
    end loop;
	r_add_st1(10) <= resize(r_mult(20),r_add_st1(10)'length); -- 21st tap
	end if;
    -- r_add_st1(11) to r_add_st1(15) are zeros
    for j in 11 to 15 loop
      r_add_st1(j)     <= (others=>'0');
    end loop;
  end if;
end process p_add_st1;

-- 16 to 8 stage 2 adder 
p_add_st2 : process (reset_n, clk)
begin
  if(reset_n='0') then
    r_add_st2     <= (others=>(others=>'0'));
  elsif(rising_edge(clk)) then
	if(input_enable(2) = '1') then
    for k in 0 to 7 loop
      r_add_st2(k)     <= resize(r_add_st1(2*k),r_add_st2(k)'length) + resize(r_add_st1(2*k+1),r_add_st2(k)'length);
    end loop;
	end if;
  end if;
end process p_add_st2;

-- 8 to 4 stage 3 adder 
p_add_st3 : process (reset_n, clk)
begin
  if(reset_n='0') then
    r_add_st3     <= (others=>(others=>'0'));
  elsif(rising_edge(clk)) then
	if(input_enable(3) = '1') then
    for k in 0 to 3 loop
      r_add_st3(k)     <= resize(r_add_st2(2*k),r_add_st3(k)'length) + resize(r_add_st2(2*k+1),r_add_st3(k)'length);
    end loop;
	end if;
  end if;
end process p_add_st3;

-- 4 to 2 stage 4 adder
p_add_st4 : process (reset_n, clk)
begin
  if(reset_n='0') then
    r_add_st4     <= (others=>(others=>'0'));
  elsif(rising_edge(clk)) then
	if(input_enable(4) = '1') then
    for k in 0 to 1 loop
      r_add_st4(k)     <= resize(r_add_st3(2*k),r_add_st4(k)'length) + resize(r_add_st3(2*k+1),r_add_st4(k)'length);
    end loop;
	end if;
  end if;
end process p_add_st4;

-- 2 to 1 stage 5 adder
p_add_st5 : process (reset_n, clk)
begin
  if(reset_n='0') then
    r_add_st5     <= (others=>'0');
  elsif(rising_edge(clk)) then
	if(input_enable(5) = '1') then
    r_add_st5     <= resize(r_add_st4(0),r_add_st5'length) + resize(r_add_st4(1),r_add_st5'length);
	end if;
  end if;
end process p_add_st5;

-- counter to keep track of decimation and assert output valid
p_decimation_count : process(reset_n, clk)
begin
  if(reset_n='0') then
	decimation_count <= 0;
	source_valid_int <= '0';
	output_valid_count  <= 0; 
  elsif(rising_edge(clk)) then
	-- start after 7th input valid and does not handle back pressure
	if(input_enable(5) = '1') then 
	-- start after 7th input valid or clock out remaining data which may handle back pressure up to 6 clocks (not tested)
	  if(decimation_count < DECIMATE_FACTOR-1) then
		if(decimation_count = 0) then
	      source_valid_int <= '1';
	      output_valid_count <= output_valid_count + 1;
		--else -- only needed if DECIMATE_FACTOR > 2 
	    --  source_valid_int <= '0';
		end if;  
	  	decimation_count <= decimation_count + 1;
	  else -- (decimation_count = DECIMATE_FACTOR-1) then  
	   	decimation_count <= 0;
		if(DECIMATE_FACTOR = 1) then
	      source_valid_int <= '1';
        else
          source_valid_int <= '0';
		end if;
	  end if;  
	else
  	  source_valid_int <= '0';
	end if;
  end if;
end process p_decimation_count;
 
source_data     <= std_logic_vector(r_add_st5(OUTPUT_WIDTH-1 downto 0));
source_valid <= source_valid_int;

-- real time error not part of avalon data
-- reserve error bits for future to check overflow bits or non return to zero inputs
source_error(1) <= '0';
source_error(0) <= '0'; 

end rtl;