//------------------------------------------------------------------------------------------------------
// @file            fir_lowpass.v
// @brief           This unit infers fir filter, 21 taps, decimation factor of 2 or or 1 (none), 
//					 sampling frequency 2khz, passes 0 to 400Hz, filters out 500hz to 1000Hz (nyquist).
//					 Coefficients are generated by http://t-filter.engineerjs.com/, pass in as parameter 
//					 It requires and expects reset at the beginning of every packet.
// 				 	Code inspired by https://surf-vhdl.com/how-to-implement-fir-filter-in-vhdl/ and
//				 	https://github.com/dbids/fir_uvm	
//					
// @author          Alex Ching
// @date            03-01-2025
// @version
// @verbatim Version  Change                                         Author  Date       \endverbatim
// @verbatim  1       initial release                                AC     06-02-2025  \endverbatim
//------------------------------------------------------------------------------------------------------
`timescale 1ns/10ps

module fir_lowpass(clk, reset_n, sink_data, sink_valid, sink_error, source_data, source_valid, source_error);
	parameter DECIMATE_FACTOR = 2; //	// 1 for no decimation
	parameter NUM_TAPS = 21;
	parameter INPUT_WIDTH = 16; // input width
	parameter OUTPUT_WIDTH = 33; // COEFF_WIDTH+INPUT_WIDTH+1 sign bit for all stage of additions
	parameter COEFF_WIDTH = 16; // tap width
	// 21 coefs....	  
	parameter COEFF_0 = -659;
	parameter COEFF_1 = -1915;
	parameter COEFF_2 = -2005;
	parameter COEFF_3 = -358;
	parameter COEFF_4 = 1679;
	parameter COEFF_5 = 1089;
	parameter COEFF_6 = -1853;
	parameter COEFF_7 = -2807;
	parameter COEFF_8 = 2077;
	parameter COEFF_9 = 10186;
	parameter COEFF_10 = 14235;
	parameter COEFF_11 = 10186;
	parameter COEFF_12 = 2077;
	parameter COEFF_13 = -2807;
	parameter COEFF_14 = -1853;
	parameter COEFF_15 = 1089;
	parameter COEFF_16 = 1679;
	parameter COEFF_17 = -358;
	parameter COEFF_18 = -2005;
	parameter COEFF_19 = -1915;
	parameter COEFF_20 = -659;	

	input clk;
	input reset_n;
	input [INPUT_WIDTH-1:0] sink_data;
	input sink_valid;
	input [1:0] sink_error; // reserved for future use

	output [OUTPUT_WIDTH-1:0] source_data;
	output source_valid;
	output wire [1:0] source_error;

	wire signed [COEFF_WIDTH-1:0] w_coeff[0:NUM_TAPS-1];
	
	reg [INPUT_WIDTH-1:0] r_data[0:NUM_TAPS-1];	
	// When you multiply two numbers of N-bit and M-bit the output dynamic of the multiplication result is (N+M)-bits.
	// 16 bit coeff x 16 bit data = 32 bit length
	reg signed [COEFF_WIDTH+INPUT_WIDTH-1:0] r_mult[0:NUM_TAPS-1];
	// 1 additional bit for overflow per stage
	reg signed [COEFF_WIDTH+INPUT_WIDTH:0] r_add_st1[0:15];
	reg signed [COEFF_WIDTH+INPUT_WIDTH+1:0] r_add_st2[0:7];
	reg signed [COEFF_WIDTH+INPUT_WIDTH+2:0] r_add_st3[0:3];
	reg signed [COEFF_WIDTH+INPUT_WIDTH+3:0] r_add_st4[0:1];
	reg signed [COEFF_WIDTH+INPUT_WIDTH+4:0] r_add_st5;	
	reg r_source_valid;
	reg [5:0] r_input_enable; 
	reg [1:0] r_decimation_count;
	reg [31:0] r_input_valid_count;
	reg [31:0] r_output_valid_count;

	// @anchor filter-calculation
	// @brief fir filter, N taps with decimation factor 
	// @details FIR filter of order N, each value of the output sequence is a weighted sum 
	// of the most recent input values: y[n] = b0x[n]+b1x[n-1]+...bNx[n-N]
	// where x[n] is input, y[n] is output, N is filter order, bi is the coefficient, where 0<=i<=N.  
	// The FIR filter is implemented fully pipelined, there is a registration stage 
	// at the output of each multiplication or addition.  
	// Depending on the generic, the MSB of output is truncated to match the output data width.
	// NOTE: the internal variables are reset only with 'reset' input, so at the beginning of
	// each scan, the first values are clear with zeros.
	// This behaviour is the same as altera IP except this reset clears all value.

	// concurrent assignment
	assign w_coeff[0] = COEFF_0;
	assign w_coeff[1] = COEFF_1;
	assign w_coeff[2] = COEFF_2;
	assign w_coeff[3] = COEFF_3;
	assign w_coeff[4] = COEFF_4;
	assign w_coeff[5] = COEFF_5;
	assign w_coeff[6] = COEFF_6;
	assign w_coeff[7] = COEFF_7;
	assign w_coeff[8] = COEFF_8;
	assign w_coeff[9] = COEFF_9;
	assign w_coeff[10] = COEFF_10;
	assign w_coeff[11] = COEFF_11;
	assign w_coeff[12] = COEFF_12;
	assign w_coeff[13] = COEFF_13;
	assign w_coeff[14] = COEFF_14;
	assign w_coeff[15] = COEFF_15;	
	assign w_coeff[16] = COEFF_16;
	assign w_coeff[17] = COEFF_17;
	assign w_coeff[18] = COEFF_18;
	assign w_coeff[19] = COEFF_19;
	assign w_coeff[20] = COEFF_20;

	// capture input and push data down to next array	
	always @ (posedge clk or negedge reset_n) begin
		if(!reset_n) begin
			for(int j=0; j<NUM_TAPS; j=j+1) begin
				r_data[j] <= '0;
			end
			r_input_valid_count <= '0;
		end else if (sink_valid) begin
			for(int j=NUM_TAPS-1; j>0; j=j-1) begin
				r_data[j] <= r_data[j-1];
			end
			r_data[0] <= sink_data;
			r_input_valid_count <= r_input_valid_count + 1;
		end
	end	

	// enable next stage addition only when new sample comes in
	always @ (posedge clk or negedge reset_n) begin
		if(!reset_n) begin
			r_input_enable <= '0;
		end else begin
			r_input_enable[5:0] <= {r_input_enable[4:0], sink_valid};
		end
	end

	// coefficient (tap) multiplier (convolution)
	always @ (posedge clk or negedge reset_n) begin
		if(!reset_n) begin
			for(int k=0; k<NUM_TAPS; k=k+1) begin
				r_mult[k] <= '0;
			end			
		end else if (r_input_enable[0]) begin
			for(int k=0; k<NUM_TAPS; k=k+1) begin
				r_mult[k] <= r_data[k] * w_coeff[k];
			end			
		end
	end
	
	// 21 tap multiplication output with addition convert to 5 stage addition, 
	// each addition stage increment bit count by 1

	// 21 to 16 stage 1 adder 
	always @ (posedge clk or negedge reset_n) begin
		if(!reset_n) begin
			for(int k=0; k<16; k=k+1) begin
				r_add_st1[k] <= '0;  // r_add_st1[11] to r_add_st1[15] are always zeros
			end			
		end else if (r_input_enable[1]) begin
			for(int k=0; k<10; k=k+1) begin
				r_add_st1[k] <= {r_mult[2*k][COEFF_WIDTH+INPUT_WIDTH-1], r_mult[2*k]} + {r_mult[2*k+1][COEFF_WIDTH+INPUT_WIDTH-1], r_mult[2*k+1]}; // resize sign bit to +1 for carryover
			end	 
			r_add_st1[10] <= {r_mult[20][COEFF_WIDTH+INPUT_WIDTH-1], r_mult[20]}; // 21st tap resize to +1 with sign bit		
		end
	end

	// 16 to 8 stage 2 adder
	always @ (posedge clk or negedge reset_n) begin
		if(!reset_n) begin
			for(int k=0; k<8; k=k+1) begin
				r_add_st2[k] <= '0;  
			end			
		end else if (r_input_enable[2]) begin
			for(int k=0; k<8; k=k+1) begin
				r_add_st2[k] <= {r_add_st1[2*k][COEFF_WIDTH+INPUT_WIDTH], r_add_st1[2*k]} + {r_add_st1[2*k+1][COEFF_WIDTH+INPUT_WIDTH], r_add_st1[2*k+1]}; // resize sign bit to +1 for carryover
			end	 	
		end
	end	

	// 8 to 4 stage 3 adder
	always @ (posedge clk or negedge reset_n) begin
		if(!reset_n) begin
			for(int k=0; k<4; k=k+1) begin
				r_add_st3[k] <= '0;  
			end			
		end else if (r_input_enable[3]) begin
			for(int k=0; k<3; k=k+1) begin
				r_add_st3[k] <= {r_add_st2[2*k][COEFF_WIDTH+INPUT_WIDTH+1], r_add_st2[2*k]} + {r_add_st2[2*k+1][COEFF_WIDTH+INPUT_WIDTH+1], r_add_st2[2*k+1]}; // resize sign bit to +1 for carryover
			end	 	
		end
	end
	
	// 4 to 2 stage 4 adder
	always @ (posedge clk or negedge reset_n) begin
		if(!reset_n) begin
			for(int k=0; k<2; k=k+1) begin
				r_add_st4[k] <= '0;  
			end			
		end else if (r_input_enable[4]) begin
			for(int k=0; k<2; k=k+1) begin
				r_add_st4[k] <= {r_add_st3[2*k][COEFF_WIDTH+INPUT_WIDTH+2], r_add_st3[2*k]} + {r_add_st3[2*k+1][COEFF_WIDTH+INPUT_WIDTH+2], r_add_st3[2*k+1]}; // resize sign bit to +1 for carryover
			end	 	
		end
	end	
	
	// 2 to 1 stage 5 adder
	always @ (posedge clk or negedge reset_n) begin
		if(!reset_n) begin
			r_add_st5 <= '0;  		
		end else if (r_input_enable[5]) begin
			r_add_st5 <= {r_add_st4[0][COEFF_WIDTH+INPUT_WIDTH+3], r_add_st4[0]} + {r_add_st4[1][COEFF_WIDTH+INPUT_WIDTH+3], r_add_st4[1]}; // resize sign bit to +1 for carryover	 	
		end
	end
	
	// counter to keep track of decimation and assert output valid
	always @ (posedge clk or negedge reset_n) begin
		if(!reset_n) begin
			r_decimation_count <= '0;
			r_source_valid <= 1'b0;
			r_output_valid_count <= '0;		
		// start after 6th input valid and does not handle back pressure
		end else if (r_input_enable[5]) begin
			if (r_decimation_count < DECIMATE_FACTOR-1) begin
				if (r_decimation_count == '0) begin
					r_source_valid <= 1'b1;
					r_output_valid_count <= r_output_valid_count + 1;
				end
				r_decimation_count <= r_decimation_count + 1;
			end else begin // (decimation_count = DECIMATE_FACTOR-1) then 
				r_decimation_count <= '0;
				if (DECIMATE_FACTOR == 1) begin
					r_source_valid <= 1'b1;
				end else begin
					r_source_valid <= 1'b0;
				end
			end
		end else begin
			r_source_valid <= 1'b0;
		end
	end
	
	assign source_data  = r_add_st5[OUTPUT_WIDTH-1:0]; // truncate sign bits
	assign source_valid = r_source_valid;

	// real time error not part of avalon data
	assign source_error[0] = r_add_st5[OUTPUT_WIDTH] ^ r_add_st5[OUTPUT_WIDTH+1] ^ r_add_st5[OUTPUT_WIDTH+2] ^ r_add_st5[OUTPUT_WIDTH+3]; // xor truncated overflow bits, if true there is overflow
	assign source_error[1] = '0; // reserve for future to detect if input does not return to zero causing FIR not to work
		

endmodule
